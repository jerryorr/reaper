<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:blogger="http://schemas.google.com/blogger/2008" xmlns:gd="http://schemas.google.com/g/2005" xmlns:georss="http://www.georss.org/georss" xmlns:openSearch="http://a9.com/-/spec/opensearchrss/1.0/" xmlns:thr="http://purl.org/syndication/thread/1.0">
   <id>tag:blogger.com,1999:blog-6466545174058573557</id>
   <updated>2014-02-12T14:17:21.008-05:00</updated>
   <category term="dojo store dijit select" />
   <category term="jsf facelets custom converter attributes" />
   <category term="open source software government petition" />
   <title type="text">Jerry on Java</title>
   <subtitle type="html">Thoughts and tips from my experiences in Java EE and web development.</subtitle>
   <link rel="http://schemas.google.com/g/2005#feed" type="application/atom+xml" href="http://blog.jerryorr.com/feeds/posts/default" />
   <link rel="self" type="application/atom+xml" href="http://www.blogger.com/feeds/6466545174058573557/posts/default" />
   <link rel="alternate" type="text/html" href="http://blog.jerryorr.com/" />
   <link rel="hub" href="http://pubsubhubbub.appspot.com/" />
   <author>
      <name>Jerry Orr</name>
      <uri>http://www.blogger.com/profile/06855141821400610431</uri>
      <email>noreply@blogger.com</email>
      <gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="25" height="32" src="http://2.bp.blogspot.com/-t8W_uziUTT8/To9NhZ9vqbI/AAAAAAAAAAc/5tVtYT29bwo/s220/jerry%2Bheadshot.jpg" />
   </author>
   <generator version="7.00" uri="http://www.blogger.com">Blogger</generator>
   <openSearch:totalResults>9</openSearch:totalResults>
   <openSearch:startIndex>1</openSearch:startIndex>
   <openSearch:itemsPerPage>25</openSearch:itemsPerPage>
   <entry>
      <published>2013-10-31T09:54:00.000-04:00</published>
      <updated>2013-10-31T09:54:54.923-04:00</updated>
      <title type="text">Using Node.js streams to massage data into the format you want</title>
      <content type="html">Google provides some pretty cool flu data in &lt;a href="http://www.google.org/flutrends/us/data.txt" target="_blank"&gt;CSV format&lt;/a&gt;, and I wanted to display that in a chart at&amp;nbsp;&lt;a href="https://www.thedash.com/" target="_blank"&gt;Dash&lt;/a&gt;. However, the raw data isn't quite right for my needs:&lt;br /&gt;&lt;ol&gt;&lt;li&gt;It has a bunch of intro/header text (copyright stuff, description of the data, etc), and Dash needs just the raw data.&lt;/li&gt;&lt;li&gt;It shows dozens of states/regions/cities, and I just want to show overall U.S. data and my home state.&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;Fortunately, Dash can read data from any publicly accessible endpoint, so I decided to throw together a quick&amp;nbsp;&lt;a href="http://nodejs.org/" target="_blank"&gt;Node.js&lt;/a&gt;&amp;nbsp;app to massage the data into what I needed. The most straightforward solution was probably to load the whole file, read through it line by line, build up an array of data, then write it out. And since the data feed is currently just under 400KB, maybe that would have been alright. But a better pattern (and more fun, IMO) is to take advantage of Node Streams. As long as we use streams throughout the entire process, we can make sure that only a small buffer is kept in memory at any given time.&lt;br /&gt;&lt;br /&gt;If you just want to see the full app,&amp;nbsp;&lt;a href="https://github.com/jerryorr/sniffles" target="_blank"&gt;it's on GitHub&lt;/a&gt;. Otherwise, read on to see my thought process.&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;h3&gt;Filter out the intro/header text&lt;/h3&gt;&lt;/div&gt;&lt;div&gt;First, we'll write a stream that filters out the copyright/overview stuff and passes on the rest:&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;pre class="brush: js"&gt;var stream = require('stream')&lt;br /&gt;  , util = require('util')&lt;br /&gt;&lt;br /&gt;function CleanIntro(options) {&lt;br /&gt;  stream.Transform.call(this, options)&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;util.inherits(CleanIntro, stream.Transform)&lt;br /&gt;&lt;br /&gt;CleanIntro.prototype._transform = function (chunk, enc, cb) {&lt;br /&gt;  if (this.readingData) {&lt;br /&gt;    this.push(chunk, enc)&lt;br /&gt;  } else {&lt;br /&gt;    // Ignore all text until we find a line beginning with 'Date,''&lt;br /&gt;    var start = chunk.toString().search(/^Date,/m)&lt;br /&gt;    if (start !== -1) {&lt;br /&gt;      this.readingData = true&lt;br /&gt;      this.push(chunk.slice(start), enc)&lt;br /&gt;    }&lt;br /&gt;  }&lt;br /&gt;  cb()&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;A Transform stream simply takes data that was piped in from another stream, does whatever it wants to it, then pushes whatever it wants back out. In our case, we're just ignoring anything before the actual data begins, then pushing the rest of the data back out. Easy.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Parse the CSV data&lt;/h3&gt;&lt;/div&gt;&lt;div&gt;Now that we have a filter to get just the raw CSV data, we can start parsing it. There are lots of CSV parsing libraries out there; I like&amp;nbsp;&lt;a href="https://npmjs.org/package/csv-stream" target="_blank"&gt;csv-stream&lt;/a&gt;&amp;nbsp;because, well, it's a stream. So our basic process is to make the HTTP request, pipe it to our header-cleaning filter, then pipe it to csv-stream and start working with the data:&lt;/div&gt;&lt;div&gt;&lt;pre class="brush: js"&gt;var request = require('request')&lt;br /&gt;  , csv = require('csv-stream')&lt;br /&gt;  , util = require('util')&lt;br /&gt;  , _ = require('lodash')&lt;br /&gt;  , moment = require('moment')&lt;br /&gt;  , OutStream = require('./out-stream')&lt;br /&gt;  , CleanIntroFilter = require('./clean-intro-filter')&lt;br /&gt;&lt;br /&gt;// Returns a Stream that emits CSV records from Google Flu Trends.&lt;br /&gt;// options:&lt;br /&gt;//   - regions: an array of regions for which data should be generated.&lt;br /&gt;//     See http://www.google.org/flutrends/us/data.txt for possible values&lt;br /&gt;module.exports = function (options) {&lt;br /&gt;  options = _.extend({&lt;br /&gt;    regions: ['United States']&lt;br /&gt;  }, options)&lt;br /&gt;&lt;br /&gt;  var earliest = moment().subtract('years', 1)&lt;br /&gt;&lt;br /&gt;  request('http://www.google.org/flutrends/us/data.txt')&lt;br /&gt;    .pipe(new CleanIntroFilter())&lt;br /&gt;    .pipe(csv.createStream({}))&lt;br /&gt;    .on('error',function(err){&lt;br /&gt;        // Oops, got an error&lt;br /&gt;    })&lt;br /&gt;    .on('data',function(data) {&lt;br /&gt;      var date = moment(data.Date)&lt;br /&gt;&lt;br /&gt;      // Only return data from the past year&lt;br /&gt;      if (date.isAfter(earliest) || date.isSame(earliest)) {&lt;br /&gt;        // Let's build the output String...&lt;br /&gt;        console.log(data.Date + ',' + _.map(options.regions, function (region) {&lt;br /&gt;          return data[region]&lt;br /&gt;        }).join())&lt;br /&gt;      }&lt;br /&gt;    })&lt;br /&gt;    .on('end', function () {&lt;br /&gt;      // Okay we're done, now what?&lt;br /&gt;    })&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;Alright, now we're getting close. We've built the CSV output, but now what do we do with it? Push it all into an array and return that? &lt;b&gt;NO!&lt;/b&gt; Remember, we'll lose the slim memory benefits of streams if we don't keep using them the whole way through.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Write out to another Stream&lt;/h3&gt;&lt;/div&gt;&lt;div&gt;Instead, let's just make our own writeable stream:&lt;/div&gt;&lt;div&gt;&lt;pre class="brush: js"&gt;var stream = require('stream')&lt;br /&gt;&lt;br /&gt;var OutStream = function() {&lt;br /&gt;  stream.Transform.call(this,{objectMode: false})&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;OutStream.prototype = Object.create(&lt;br /&gt;  stream.Transform.prototype, {constructor: {value: OutStream}} )&lt;br /&gt;&lt;br /&gt;OutStream.prototype._transform = function(chunk, encoding, callback) {&lt;br /&gt;  this.push(chunk, encoding)&lt;br /&gt;  callback &amp;amp;&amp;amp; callback()&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;OutStream.prototype.write = function () {&lt;br /&gt;  this._transform.apply(this, arguments)&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;OutStream.prototype.end = function () {&lt;br /&gt;  this._transform.apply(this, arguments)&lt;br /&gt;  this.emit('end')&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;And now our parsing function can return that stream and write to it: &lt;br /&gt;&lt;pre class="brush: js"&gt;module.exports = function (options) {&lt;br /&gt;  options = _.extend({&lt;br /&gt;    regions: ['United States']&lt;br /&gt;  }, options)&lt;br /&gt;&lt;br /&gt;  var out = new OutStream()&lt;br /&gt;  out.write('Date,' + options.regions.join())&lt;br /&gt;&lt;br /&gt;  var earliest = moment().subtract('years', 1)&lt;br /&gt;&lt;br /&gt;  request('http://www.google.org/flutrends/us/data.txt')&lt;br /&gt;    .pipe(new CleanIntroFilter())&lt;br /&gt;    .pipe(csv.createStream({}))&lt;br /&gt;    .on('error',function(err){&lt;br /&gt;        out.emit('error', err)&lt;br /&gt;    })&lt;br /&gt;    .on('data',function(data) {&lt;br /&gt;      var date = moment(data.Date)&lt;br /&gt;&lt;br /&gt;      // Only return data from the past year&lt;br /&gt;      if (date.isAfter(earliest) || date.isSame(earliest)) {&lt;br /&gt;        out.write(data.Date + ',' + _.map(options.regions, function (region) {&lt;br /&gt;          return data[region]&lt;br /&gt;        }).join())&lt;br /&gt;      }&lt;br /&gt;    })&lt;br /&gt;    .on('end', function () {&lt;br /&gt;      out.end()&lt;br /&gt;    })&lt;br /&gt;&lt;br /&gt;  return out&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h3&gt;Serve it up&lt;/h3&gt;&lt;/div&gt;&lt;div&gt;Finally, we'll use&amp;nbsp;&lt;a href="http://expressjs.com/" target="_blank"&gt;Express&lt;/a&gt;&amp;nbsp;to expose our data as a web endpoint:&lt;/div&gt;&lt;div&gt;&lt;pre class="brush: js"&gt;var express = require('express')&lt;br /&gt;  , data = require('./lib/data')&lt;br /&gt;  , _ = require('lodash')&lt;br /&gt;&lt;br /&gt;var app = express()&lt;br /&gt;&lt;br /&gt;app.get('/', function(req, res){&lt;br /&gt;  var options = {}&lt;br /&gt;&lt;br /&gt;  if (req.query.region) {&lt;br /&gt;    options.regions = _.isArray(req.query.region) ? req.query.region : [req.query.region]&lt;br /&gt;  }&lt;br /&gt;&lt;br /&gt;  res.setHeader('Content-Type', 'text/csv')&lt;br /&gt;&lt;br /&gt;  data(options)&lt;br /&gt;    .on('data', function (data) {&lt;br /&gt;      res.write(data)&lt;br /&gt;      res.write('\n')&lt;br /&gt;    })&lt;br /&gt;    .on('end', function (data) {&lt;br /&gt;      res.end()&lt;br /&gt;    })&lt;br /&gt;    .on('error', function (err) {&lt;br /&gt;      console.log('error: ', error)&lt;br /&gt;    })&lt;br /&gt;})&lt;br /&gt;&lt;br /&gt;var port = process.env.PORT || 5000&lt;br /&gt;app.listen(port)&lt;br /&gt;console.log('Listening on port ' + port)&lt;/pre&gt;&lt;br /&gt;Once again, note that as soon as we get data from our stream, we manipulate and write it out to another stream (the HTTP response, in this case). This keeps us from holding a lot of data in memory unnecessarily.&lt;br /&gt;&lt;br /&gt;Now if we fire up the server, we can use curl to see it in action:&lt;br /&gt;&lt;br /&gt;&lt;pre class="brush: text"&gt;$ curl 'http://localhost:5000'&lt;br /&gt;Date,United States&lt;br /&gt;2012-11-04,2492&lt;br /&gt;2012-11-11,2913&lt;br /&gt;2012-11-18,3040&lt;br /&gt;2012-11-25,3641&lt;br /&gt;2012-12-02,4427&lt;br /&gt;[and so on]&lt;br /&gt;&lt;br /&gt;$ curl 'http://localhost:5000?region=United%20States&amp;amp;region=Pennsylvania'&lt;br /&gt;Date,United States,Pennsylvania&lt;br /&gt;2012-11-04,2492,2579&lt;br /&gt;2012-11-11,2913,2889&lt;br /&gt;2012-11-18,3040,2785&lt;br /&gt;2012-11-25,3641,3248&lt;br /&gt;2012-12-02,4427,3679&lt;br /&gt;[and so on]&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As long the server is running someplace that is accessible to the public, we can head on over to&amp;nbsp;&lt;a href="http://thedash.com/" target="_blank"&gt;Dash&lt;/a&gt;&amp;nbsp;and plug it into a Custom Chart widget, giving us something like this:&lt;br /&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://3.bp.blogspot.com/-L56A2zETw1A/UnJfQJdvz-I/AAAAAAAABxU/lthJBmR2nIE/s1600/flu+chart+in+Dash.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="264" src="http://3.bp.blogspot.com/-L56A2zETw1A/UnJfQJdvz-I/AAAAAAAABxU/lthJBmR2nIE/s640/flu+chart+in+Dash.png" width="640" /&gt;&lt;/a&gt;&lt;/div&gt;Hey, looks like December and January are big months for the flu in the U.S. Who knew?&lt;br /&gt;&lt;br /&gt;Want to try this yourself? The full source for this app &lt;a href="https://github.com/jerryorr/sniffles" target="_blank"&gt;is on GitHub&lt;/a&gt;, along with step-by-step instructions for running the project and creating a widget in Dash. Enjoy!&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;link href="//cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/styles/shCore.min.css" rel="stylesheet" type="text/css"&gt;&lt;/link&gt;  &lt;link href="//cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/styles/shThemeRDark.min.css" rel="stylesheet" type="text/css"&gt;&lt;/link&gt;  &lt;script src="//cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shCore.min.js" type="text/javascript"&gt;&lt;/script&gt;  &lt;script src="//cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushJScript.min.js" type="text/javascript"&gt;&lt;/script&gt;  &lt;script src="//cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushPlain.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;SyntaxHighlighter.config.bloggerMode = true; SyntaxHighlighter.defaults['toolbar'] = true; SyntaxHighlighter.defaults.gutter = false; SyntaxHighlighter.all(); &lt;/script&gt;&lt;style&gt;div.syntaxhighlighter { padding: 5px; }&lt;/style&gt;</content>
      <author>
         <name>Jerry Orr</name>
         <uri>http://www.blogger.com/profile/06855141821400610431</uri>
         <email>noreply@blogger.com</email>
         <gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="25" height="32" src="http://2.bp.blogspot.com/-t8W_uziUTT8/To9NhZ9vqbI/AAAAAAAAAAc/5tVtYT29bwo/s220/jerry%2Bheadshot.jpg" />
      </author>
      <media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://3.bp.blogspot.com/-L56A2zETw1A/UnJfQJdvz-I/AAAAAAAABxU/lthJBmR2nIE/s72-c/flu+chart+in+Dash.png" height="72" width="72" />
      <thr:total>0</thr:total>
   </entry>
</feed>